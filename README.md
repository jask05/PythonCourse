# PythonCourse

Curso de Python - [Píldoras informáticas](https://www.youtube.com/watch?v=G2FCfQj-9ig&list=PLU8oAlHdN5BlvPxziopYZRd55pdqFwkeS)

## Vistos

1. [Vídeo 1](https://www.youtube.com/watch?v=G2FCfQj-9ig&index=1&list=PLU8oAlHdN5BlvPxziopYZRd55pdqFwkeS)
2. Introducción. [Vídeo 2](https://www.youtube.com/watch?v=9ojhJsXNWCI&list=PLU8oAlHdN5BlvPxziopYZRd55pdqFwkeS&index=2)
3. Sintaxis Básica I. [Vídeo 3](https://www.youtube.com/watch?v=yppT6GPZMyo&index=3&list=PLU8oAlHdN5BlvPxziopYZRd55pdqFwkeS)
4. Sintaxis Básica II Tipos, operadores y variables. [Vídeo 4](https://www.youtube.com/watch?v=u4I9PqhqCo8&list=PLU8oAlHdN5BlvPxziopYZRd55pdqFwkeS&index=4)
5. Sintaxis Básica III Funciones I. [Vídeo 5](https://www.youtube.com/watch?v=VY448UWAQ_0&list=PLU8oAlHdN5BlvPxziopYZRd55pdqFwkeS&index=5)
6. Sintaxis Básica IV Funciones II. [Vídeo 6](https://www.youtube.com/watch?v=vawEHhV_HFA)
7. Sintaxis Básica V. Las listas. [Vídeo 7](https://www.youtube.com/watch?v=Q8hugySbLQQ)
8. Sintaxis Básica VI. Las tuplas. [Vídeo 8](https://www.youtube.com/watch?v=Ufqh8aoR9hE)
9. Sintaxis Básica VII Los diccionarios. [Vídeo 9](https://www.youtube.com/watch?v=2OmgHl8lp0I)
10. Condicionales I. [Vídeo 10](https://www.youtube.com/watch?v=iV-4F0jGWak)
11. Condicionales II. [Vídeo 11](https://www.youtube.com/watch?v=cf7o4s9nFu8)
12. Condicionales III. [Video 12](https://www.youtube.com/watch?v=qxgEolsC6rg)
13. Condicionales IV. [Video 13](https://www.youtube.com/watch?v=rDGsWYnQEJY)
14. Bucles I. For. [Video 14](https://www.youtube.com/watch?v=GQGhU1526Oo)
15. Bucles II. For. [Video 15](https://www.youtube.com/watch?v=D416qOEDrhI)
16. Bucle III. For. [Video 16](https://www.youtube.com/watch?v=KFz-mXB7qVI)
17. Bucles IV. While. [Video 17](https://www.youtube.com/watch?v=UfUM6uzl5SM)
18. Bucles V. Continue, pass y else. [Video 18](https://www.youtube.com/watch?v=c8WCRTU4udo)
19. Generadores I. [Video 19](https://www.youtube.com/watch?v=TLVnoqXGWpY)
20. Generadores II. [Video 20](https://www.youtube.com/watch?v=ucaHqGII350)
21. Excepciones I. [Video 21](https://www.youtube.com/watch?v=2MaAs7XU2T0)
22. Excepciones II. [Video 22](https://www.youtube.com/watch?v=HH3c6ZBvSx8)
23. Excepciones III. [Video 23](https://www.youtube.com/watch?v=dLH-oay4Bts)
24. POO I. [Video 24](https://www.youtube.com/watch?v=5Ohme4A2Weg)
25. POO II. [Video 25](https://www.youtube.com/watch?v=2UNrSiKEI8w)
26. POO III. [Video 26](https://www.youtube.com/watch?v=Y_SiIgxc-xI)
27. POO IV. [Video 27](https://www.youtube.com/watch?v=x5CY8fVyYLo)
28. POO V. [Video 28](https://www.youtube.com/watch?v=OU-e2uhoGxE)
29. POO VI. Herencia I. [Video 29](https://www.youtube.com/watch?v=u_VbLsIyzRk)
30. POO VII. Herencia II. [Video 30](https://www.youtube.com/watch?v=jMQQN9OxwVc)
31. POO VIII. Herencia III. [Video 31](https://www.youtube.com/watch?v=oe04X1B14YY)
32. POO IX. Polimorfismo I. [Video 32](https://www.youtube.com/watch?v=kV1cN_bqcSw)
33. Métodos de cadenas. [Video 33](https://www.youtube.com/watch?v=zH0VsRuD2ok)
34. Módulos. [Video 34](https://www.youtube.com/watch?v=t93x-vnFvP4)
35. Paquetes. [Video 35](https://www.youtube.com/watch?v=nRieWujis4s)
36. Paquetes distribuibles. [Video 36](https://www.youtube.com/watch?v=Zf9sN-w0BVE)
37. Archivos externos I. [Video 37](https://www.youtube.com/watch?v=V87m9SltcI8)
38. Archivos externos II. [Video 38](https://www.youtube.com/watch?v=0dEYVSRYl_s)
39. Serialización I. [Video 39](https://www.youtube.com/watch?v=SOimkkfQIOM)
40. Serialiación II. [Video 40](https://www.youtube.com/watch?v=CkfDnMC79b4)
41. Guardado permanente. [Video 41](https://www.youtube.com/watch?v=J3qvf1fTCsU)
42. Interfaces gráficas I. [Video 42](https://www.youtube.com/watch?v=hTUJC8HsC2I)
43. Interfaces gráficas II. [Video 43](https://www.youtube.com/watch?v=M80CzDC1Crc)
44. Interfaces gráficas III. [Video 44](https://www.youtube.com/watch?v=Nf4-gvf-tNg)
45. Interfaces gráficas IV. [Video 45](https://www.youtube.com/watch?v=YRs8j0QGEn0)
46. Interfaces gráficas V. [Video 46](https://www.youtube.com/watch?v=nZF9SwhmPRo)
47. Interfaces gráficas VI. [Video 47](https://www.youtube.com/watch?v=kbTl3DaFJUk)
48. Interfaces gráficas VII. [Video 48](https://www.youtube.com/watch?v=oIzt6ESA7nU)
49. Interfaces gráficas VIII. [Video 49](https://www.youtube.com/watch?v=oIzt6ESA7nU)
50. Interfaces gráficas IX - Radiobuttons. [Video 50](https://www.youtube.com/watch?v=YfYUOUGMaXU)
51. Interfaces gráfficas X - Checkbuttons. [Video 51](https://www.youtube.com/watch?v=TzeU61X-dnI)
52. Interfaces gráfficas XI - Menu. [Video 52](https://www.youtube.com/watch?v=Dv1ALaWwScI)
53. Interfaces gráfficas XII - Ventanas emergentes. [Video 53](https://www.youtube.com/watch?v=xUGUglpaTJc)
54. Interfaces gráfficas XIII - Ventanas emergentes - Abrir archivos. [Video 54](https://www.youtube.com/watch?v=TmQZBzwIMGk)
55. BBDD I. [Video 55](https://www.youtube.com/watch?v=ZJuVQ9jUg-A)
56. BBDD II. [Video 56](https://www.youtube.com/watch?v=eM0MkDc34qo)
57. BBDD III. [Video 57](https://www.youtube.com/watch?v=HVd6mPiD3pc)
58. BBDD IV. [Video 58](https://www.youtube.com/watch?v=m_FzVf9JTV8)
59. Práctica guiada I - Introducción. [Video 59](https://www.youtube.com/watch?v=E0OqddzjFUY)
60. Práctica guiada II. [Video 60](https://www.youtube.com/watch?v=o8E869dmK3U)
61. Práctica guiada III - Grid. [Video 61](https://www.youtube.com/watch?v=OJzFGgOSpvI)
62. Práctica guiada IV - Conexión BBDD y Salir. [Video 62](https://www.youtube.com/watch?v=5XPLCDp7nDk)
63. Práctica guiada V - Limpiar campos e insertar registros. [Video 63](https://www.youtube.com/watch?v=mNzHPglBuUk)
64. Práctica guiada VI - Leer y actualizar registros. [Video 64](https://www.youtube.com/watch?v=nx3OE31y0IY)
65. Práctica guiada VII - Borrar registros y consultas parametrizadas. [Video 65](https://www.youtube.com/watch?v=nj-alxd7YvM)
66. Función Lambda. [Video 66](https://www.youtube.com/watch?v=tfYLcHbjc_A)
67. Función Filter. [Video 67](https://www.youtube.com/watch?v=mTJKU7IxL0U)
68. Función Map. [Video 68](https://www.youtube.com/watch?v=4dkjpHI6vpA)
69. Expresiones Regulares I. [Video 69](https://www.youtube.com/watch?v=qpwn3gRtxCo)
70. Expresiones Regulares II. [Video 70](https://www.youtube.com/watch?v=V8316ao08tQ)
71. Expresiones Regulares III. [Video 71](https://www.youtube.com/watch?v=Q4vXCQd1zwc)
72. Expresiones Regulares IV. [Video 72](https://www.youtube.com/watch?v=u3WBRgpxQcc)
73. Decoradores I. [Video 73](https://www.youtube.com/watch?v=DQXm6bIZgvk)
74. Decoradores II. [Video 74](https://www.youtube.com/watch?v=_IwlE3Z7U04)
75. Documentación. [Video 75](https://www.youtube.com/watch?v=SJqANWdRG4I)
76. Documentación y pruebas. [Video 76](https://www.youtube.com/watch?v=BUNEkSFlmys)
77. Documentación y pruebas II. [Video 77](https://www.youtube.com/watch?v=64v9X7K-iuc)

# Apuntes

## Vídeo 1
- URLs interesantes:
    - [Referencia de la Biblioteca Python](http://pyspanishdoc.sourceforge.net/lib/lib.html)

## Vídeo 2

- Creado por Guido Van Rossum.
- Lenguaje de alto nivel. Gramática sencilla, clara y muy legible.
- Tipado dinámico y fuerte.
- Orientado a objetos.
- Librerías estándar.
- Interpretado.

## Vídeo 3 - Sintaxis básica I

- \>>> Prompt
```python
print ("Hola alumnos"); print("Adios")
```
- Comentarios en una línea con #
- \ dentro de un string hace un salto de línea pero solo a nivel visual del código.
- Identación.

## Vídeo 4 - Sintaxis básica II

- **Tipos de datos**
    - Numéricos
        - Enteros (int)
        - Coma flotante (float)
        - Complejos
    - Textos
    - Booleanos
        - True
        - False

- **Operadores**
    - Aritméticos
        - Suma: +
        - Resta: -
        - Multiplicación: *
        - División: /
        - Módulo (resto): %
        - Exponente (potencia): **
        - División entera (nº entero de una división): //
    - Comparación
    - Lógicos
    - Asignación
    - Especiales

- **Variable**: espacio en la memoria del ordenador donde se almacenará un valor que podrá cambiar durante la ejecución del programa. Empieza con una letra mayúscula o minúscula. Contiene letras, cifras y guió bajo.

- **Condicional if**:

```python
numero1=5
numero2=7
if numero1>numero2:
	print("El numero1 es mayor")
else:
	print("El numero2 es mayor")
```


## Video 5 - Sintaxis Básica III Funciones I
- **Qué son?** 
    - Una o varias líneas de código agrupadas de forma que funcionan como una unidad realizando una tarea específica.
    - Pueden devolver valores.
    - Pueden tener parámetros/argumentos.
    - Se les llama "métodos" cuando se encuentran definidas dentro de una clase.
- **Utilidad**
    - Reutilización de código.
- **Sintáxis**
```python
def nombre_funcion(parametro) # parámetro opcional
	# instrucción de la función
	return # opcional

# Ejecución
nombre_funcion(parametro)
```

## Vídeo 6 - Sintaxis Básica IV Funciones II
- Parámetros separados por coma.
- Pueden tener de 0 a n.
- Pueden devolver valor con **return**.

## Vídeo 7 - Sintaxis Básica V. Las listas.
- Equivalente a arrays/vectores.
- Permite almacenar en la memoria del ordenador varios valores.
- Variable = cajón // Lista = estantería (simil)
- Permiten guardar diferentes tipos de valores.
- Se pueden expandir dinámicamente.
- Índice: posición dentro de la lista. Empieza por **0**.

```python
nombreLista = [e1, e2, e3 ...]

# Muestra toda la lista
lista[:]

# Tercer elemento (empieza en 0)
lista[2]

# De atrás hacia delante
lista[-3]

# Los tres primeros
lista[0:3] # El uĺtimo nº es exclusión.

# Acceso a los dos últimos elementos
lista[2:]

# Añadir elementos al final de la lista
lista.append("Luis")

# Añadir elemento al comienzo de la lista
# Primer parámetro: posición donde añadirlo.
lista.insert(0,"Mariano")

# Añadir varios elementos a la vez
lista.extend(["ele1", "ele2", "ele3"])

# Índice de donde está un elemento
lista.index("ele1")

# Devuelve True/False si el elemento se encuentra o no en la lista
print("elemento" in lista)

# Eliminar elementos
lista.remove("elemento")

# Elimina último elemento añadido a la lista
lista.pop()

# Sumar listas diferentes
lista = ["ele1", "ele2", "ele3"]
lista2 = ["ulu1", "ulu2", "ulu3"]
lista3 = lista + lista2

# Repite la lista X veces
lista = ["ele1", "ele2", "ele3"] * 3
```

## Video 8 - Sintaxis Básica VI. Las tuplas.
- Listas inmutables (ni añadir, ni eliminar, ni modificar elementos).
- Permiten extraer porciones, pero el resultado es una tupla nueva.
- ~~No permiten utilizar búsquedas (index).~~ A partir de Python 2.6 se puede utilizar el método _index_ en las tuplas.
- Se puede comprobar si un elemento se encuentra dentro de la tupla.
- Utilidad:
    - Más rápida a la hora de ejecutarse.
    - Menos espacio (mayor optimización).
    - Formatean cadenas (strings).
    - Se pueden utilizar de claves en un diccionario (las listas no).

```python
tupla = ("e1", "e2", "e3")
# Los parámetros son opcionales, pero es recomendable ponerlos.

# Acceso
tupla[0]

# Convierte tupla en lista
lista = list(tupla)

# Convierte lista en tupla
tupla = tuple(lista)

# Contar cuántos elementos se encuentran dentro de una tupla
tupla.count(13)

# Averiguar longitud de la tupla
len(tupla)

# Tuplas unitarias: con un único elemento.
tupla = ("elemento", )

# Empaquetado de tupla. (Tuplas sin paréntesis)
tupla = "e1", "e2", "e3"

# Desempaquetado de tupla.
# Permite asignar todos los elementos que forman parte de una tupla a diferentes variables
tupla = ("Juan", 13, 1, 1955)
nombre, dia, mes, anio = tupla
```

## Video 9 - Sintaxis Básica VII Los diccionarios.
- Estructura de datos parecida a las listas y tuplas. 
- Los datos se almacenan como **clave:valor**.
- Permite almacenar listas y otros diccionarios.
- Los elementos no están ordenados. El orden es indiferente a la hora de almacenar información en un diccionario.

```python
diccionario = {"clave":"valor", "clave":"valor"...}
print(diccionario)
print(diccinario["clave"])

# Agregar/sobrescribe elemento
diccionario["nuevaclave"]="nuevovalor"

# Eliminar elemento
del diccionario["clave"]

# Devuelve las claves: keys
diccionario.keys()

# Devuelve los valores
diccionario.values()

# Devuelve la longitud del diccionario
len(diccionario)
```

## Video 10 - Condicionales I
- Flujo de ejecución: orden que sigue un programa a la hora de ejecutarse. Suele ser de arriba hacia abajo, pero puede variar.

```python
if elemento:
    condición
# Hay que tener en cuenta el ámbito de la variable. Si se declara dentro de una función, solo "funcionará" aquí dentro. No se puede manipular fuera de la función.

# Solicitud de valor. Se le puede pasar un texto descriptivo.
variable = input("Introduce un valor: ") # Por defecto se considera un valor como texto.
variable2 = int(input())
```

## Video 11 - Condicionales II
```python
if comprobación:
    condición
elif comprobación:
    condición
else
    condición
```

## Video 12 - Condicionales III
- Switch: no existe este condicional.
- Se puede utilizar concatenación de operadores de comparación a la hora de construir un condicional.
- Se puede utilizar operadores lógicos AND y OR. También existe "in" para evaluar varias condiciones.
```python
# Se lee de izquierda a derecha. Si la primera condición es "falsa", pasaría a ejecutar el else. En cambio si es "verdadera" evalua la siguiente condición. Si es falsa, pasa al else, si no, ejecuta la condición.
if 0 < edad < 100:
    print("Edad correcta.")
else:
    print("Edad incorrecta.")

# Convierte a string una variable
str(variable)
```

## Video 13 - Condicionales IV
- Operadores lógicos **and** y **or**. **And** se podría traducir como un "y si además", y el **or** "o si no".
- **in**: compara lo que se almacena en una variable con varios valores.

```python
if asignatura in ("Informática gráfica", "Pruebas de software", "Usabilidad y accesibilidad"):
    # contenido

# Para que no sea case sensitive...
lower() # Transforma el valor a minúsculas
upper() # Transforma el valor a mayúsculas
```

## Video 14 - Bucles I. For
- Utilidad: repetir una línea de código una o varias veces.
- Tipos:
    - Determinados: se ejecutan un úmero determinado de veces y se sabe a priori cuántas veces se va a ejecutar el código del interior del bucle.
    - Indeterminados: se ejecutan un número indeterminado de veces y no se sabe a priori cuántas veces se va a ejecutar. El nº de veces dependerá de la circunstancia del programa.

```python
for variable in elemento a recorrer:
    cuerpo del bucle

# Elemento a recorrer: lista, tupla, string, rango, etc.
```

## Video 15 - Bucles II. For
- Recorrido de strings.
- Tipo "range".
- Notaciones especiales con print.

```python
for i in ["Pildoras", "Informáticas", 2019]:
    print("Hola", end="") # No hace salto de línea
```

## Video 16 - Bucles III. For
- Notación especial con print.

```python
for i in range(5):
    print(f"Valor de la variable: {i}")
    # f-strings
    # Unir texto con variables.
```

## Video 17 - Bucles IV. Bucle While
- Se desconoce cuántas veces se va a ejecutar hasta que se sepa con exactitud.
```python
while condicion:
	# cuerpo del bucle
```

## Video 18 - Bucles V. Bucles: continue, pass y else
- **Continue**: salta a la siguiente iteración del bucle. Ignora esa vuelta de bucle y saltaría a la siguiente.
- **Pass**: devuelve "null" en cuanto se lee el bucle, es como si no se ejecuta esa iteración. Se suele usar en clases nulas (para dejarla para después) o para bucles sin definir.
- **Else**: funciona como en un condicional. Se ejecuta cuando el bucle está vacío, cuando haya terminado de recorrer el texto (haya completado todas las vueltas)

## Video 19 - Generadores I
- Estructuras que extraen valores de una función que se almacenan en objetos iterables. Se pueden recorrer con un bucle (while/for) o con iteradores.
- Los valores se almacenan de uno en uno.
- Cada vez que se almacene un valor, el generador permanece en un estado de stand-by o pausa. Llamado: suspensión de estado.
- ¿Ventajas? 
    - Más eficientes que funciones tradicionales. No guarda todos los elementos en memoria, si no que va 1 a 1 (más rápido).
    - Muy útiles con lista de valores infinitos: generar Ips al azar.
    - En algunos escensarios, será más útil que un generador devuelva los valores de uno en uno.

    
```python
# Función tradicional
""" El control de flujo pasa de la llamada a la función. Genera la lista de nº pares y con la instrucción return devuelve la lista, y al devolverla, el control de flujo de la ejecución vuelve otra vez donde se generó la llamada. """
def generaNumeros():
    return numeros

# Generador
"""
Hay una función, con líneas de código que construyen la lista. En lugar de la instrucción return, estaría la instrucción yield. Gracias a esta, lo que se consigue es que cuando en el código hay una llamada a esa función, el control de ejecución pasa a esa función, y la instrucción yield construye un objeto iterable con el primer valor de esa lista (ej nº pares). Se construye un objeto generador iterable en el cual está almacenado el primer valor que nos ha de devolver. Una vez generado ese objeto pasa a stand-by (suspensión) y el control de flujo de ejecución pasa otra vez al algoritmo donde se hizo la llamada. Si se vuelve a llamar al generador vuelve a obtener el segundo valor y entra en suspensión. Se devuelven los valores de 1 en 1 dentro de un objeto generador iterable."""
def generarNumeros():
    yield numeros
```

## Video 20 - Generadores II
- Cuando se utiliza **yield from** lo que se hace es simplificar el código de los generadores en el caso de utilizar bucles anidados.
- Se parece un array de 2 dimensiones.

```python
# Cuando se coloca un asterisco se indica que recibe nº
# indeterminado de elementos y también se le indica
# que estos argumentos serán tuplas
# Yield from simplifica la siguiente sintáxis
"""
def devuelve_ciudades(*ciudades):
    for elemento in ciudades:
        for subElemento in elemento:
            yield subElemento
"""
def devuelve_ciudades(*ciudades):
    for elemento in ciudades:
        yield from elemento

ciudades_devueltas=devuelve_ciudades("Madrid", "Barcelona", "Valencia", "Bilbao")

print(next(ciudades_devueltas))
print(next(ciudades_devueltas))
```

## Video 21 - Excepciones
- **¿Qué es?** error en tiempo de ejecución. Cuando hay un programa correctamente escrito, sin error de sintáxis, pero pasa algo inesperado.
- "Intenta ejecutar esta parte del código y si no puedes continúa."

## Video 22 - Excepciones II
- Capturar varias excepciones.
- Cláusula **finally**. Se ejecuta siempre, tanto si ocurre o no una excepción.

## Video 23 - Excepciones III
- Instrucción **raise**.
- Creación de excepciones propias.
```python
def evaluaEdad(edad):
    if edad<0:
        raise TypeError("No se permiten edades negativas")

print(evaluaEdad(-18))
```

## Video 24 - POO I
- Paradigmas de programación
    - Orientado a procedimientos (antiguos): Fortran, Cobol, Basic...
    - Programación Orientado a objetos
- ¿Qué es?:
    - Trasladar el comportamiento de los objetos reales a código.
    - Los objetos tienen un estado, un comportamiento (¿qué pueden hacer?), y unas propiedades.
- Ejemplo (coche):
    - **Estado**: parado, circulando, aparcado, etc.
    - **Propiedades (atributos)**: color, peso, tamaño, etc.
    - **Métodos (Comportamiento)**: Función especial que pertenece a la clase donde se crea. La función no pertenece a ninguna clase. Puede arrancar, frenar, girar, acelerar, etc.
        - **self**: hace referencia al propio objeto perteneciente a la clase.
- Ventajas:
    - Programa dividido en "partes" (módulos,clases, etc.). Modularización.
    - Código reutilizable. Herencia.
    - Si existe algún fallo el programa no cae, sigue funcionando.
    - Encapsulamiento.

## Video 25 - POO II
- Vocabulario:
    - **Clase**: modelo donde se redactan las características comunes de un grupo de objetos. Coche => chasis, 4 ruedas.
    - **Objeto / Ejemplar de clase / instacia de clase / ejemplarizar una clase**: objeto o ejemplar perteneciente a una clase. Comparten una serie de características comunes, y luego cada uno de ellos tiene sus propias características.
    - **Modularización**: aplicación con varias clases. Cada elemento puede funcionar de forma independiente.
    - **Encapsulamiento / encapsulación**: el funcionamiento interno de un objeto está protegido del exterior. Una clase "no sabe" lo que hace otra clase. Las clases se "conectan" utilizando **métodos de acceso.** Solo tendrán acceso a ciertas características de algunas clases.
    - **Herencia**: 
    - **Polimorfismo**:
    - **Nomenclatura del punto:** 
        - Objeto: miCoche
        - Acceso a propiedades: miCoche.valor // miCoche.color // miCoche.altura
        - Acceso a comportamientos: miCoche.arranca() // miCoche.frena() // miCoche.gira()

## Video 26 - POO III
- El **self** dentro de un método se "traduce" como el nombre de la variable con la que se instancia la clase.

```python
class Coche():
    enmarcha = Flase

    def arrancar(self):
        self.enmarcha = True

miCoche = Coche()
miCoche.arrancar() # True // Traducción: miCoche.enmarcha = Ture
```

## Video 27 - POO IV
- **Constructor**: método especial que le da estado inicial a los objetos. Forma de especificar claramente cual va a ser el estado inicial de los objetos que pertenezcan a una clase.
- **Encapsulación:** protege una propiedad para que no se pueda modificar desde fuera de la clase. Para ello se pone dos guiones bajos en el nombre de la variable. **IMPORTANTE**: cuando se usa la variable hay que poner los dos guiones bajos. Si se llama a la variable como "ruedas" en vez de "__ruedas" estaríamos hablando de dods variables diferentes.

```python
self.__ruedas = 4
```

## Video 28 - POO V
- **Encapsulación de métodos:** igual que con las variables, utilizando guión bajo. Se deben encapsular cuando el objeto o la clase así lo necesite. Depende del comportamiento que se busque que tenga según el propio criterio del desarrollo.

## Video 29 - POO VI. Herencia
- **¿Qué es?**: clase 1 (clase padre/superclase) => clase 2 (subclase/superclase). Conjunto de clases que toman elementos de otras.
- **¿Para qué sirve?**: Reutilización de código. Preguntarse qué características en común tienen todos los objetos. También qué comportamientos en común tienen entre todos.
- **¿Cómo hacer que las clases hereden?**: Se engloban todos las propiedades y métodos en una clase/superclase. Las particularidades se construyen en sus propias clases.

## Video 30 - POO VII. Herencia II
- Sobre escritura de métodos.
- **Herencia simple y múltiple**: hereda el constructor de la primera clase asignada en la herencia múltiple (más a la izquierda).

## Video 31 - POO VIII. Herencia III
- Como depende de que clase herede primera, puede heredar su **init** o no. La solución **no elegante** es duplicar ese init que se necesita en el de la clase que va a heredar. La **mejor solución** es utilizar el método **super()**.
- **super()**: llama al método de la clase padre.
- **isinstance()**: informa si un objeto es instancia de una clase determinada. Devuelve True o False. **No hace falta utilizar self.**

## Video 32 - POO. Polimorfismo.
- **Polimorfismo**: "muchas formas". Un objeto puede cambiar de forma dependiendo del contexto donde se utilice el método/compotamiento. Se tienen que llamar todos los métodos de la misma clase de la misma manera.

## Video 33 - Métodos de cadenas (strings)
- **upper()**: convierte en mayúscula todas las letras de un string.
- **lower()**: convierte en minúsculas todas las letras de un string.
- **capitalize()**: string pone la primera letra en mayúscula.
- **count()**: cuenta cuantas veces aparece una letra o una cadena de caractéres dentro de un texto.
- **find()**: representa el índice, la posición, en la cual aparece un carácter o un grupo de ellos dentro de un texto.
- **isdigit()**: comprueba si un dígito es valor númérico o no. Devuelve True/False.
- **isalum()**: comprueba si los caracteres son alfanuméricos.
- **isalpha()**: comprueba si hay solo letras. Espacios NO cuentan.
- **split()**: separa por palabras utilizando espacios.
- **strip()**: borra los espacios sobrantes al principio y final.
- **replace()**: cambia una palabra/letra por otra.
- **rfind()**: representa el índice de un carácter, pero lo hace contando desde atrás.
- [Más métodos...](http://pyspanishdoc.sourceforge.net/lib/string-methods.html)

## Video 34 - Módulos
- Archivo con extensión .py o .pyc (python compilado), o archivos escritos en C para CPython que posee su propio espacio de nombres y que puede contener variables, funciones, clases e incluso otros módulos.
- Sirven para organizar y reutilizar el código (modularización y reutilización).
- ¿Cómo se crean? Es un archivo con extensión .py
- Cuando se importa el módulo se utiliza la nomenclatura del punto. **Nombre_objeto.propiedad/método**. 
    - Para que sea más fácil de usar hay que modificar la directiva import. **from <nombre módulo> import <función a usar>**.
    - Si se quiere usar todo el código que hay dentro del módulo, se usa from <módulo> import *. Con el * se reserva un espacio muy grande de memoria porque se guardaría espacio para todo el módulo.
    - Si no encuentra el módulo en el mismo nivel (path) utiliza el **syspath**.

## Video 35 - Paquetes
- Directorios/carpetas donde se almacenan los módulos relacioandos entre si.
- Se utilizan para organizar y reutilizar código.
- **¿Cómo se crea?**: Hay que crear una carpeta con un archivo **__init__.py**.
- Se pueden crear subpaquetes: paquetes dentro de un paquete.

## Video 36 - Paquetes distribuibles
- Para que se puedan reutilizar por diferentes personas o diferentes proyectos. 
- Se pueden enviar por correo o subirlos a una plataforma.
- Se instala el paquete dentro de Python del SO.
- Hay que crear en la raíz un fichero **setup.py**.

```python
python3 setup.py sdist
```

- Ejecutado el comando debe crear una carpeta denominada **<nombre>.egg-info** y **dist**.
- Para instalar ir al directorio **dist** y utilizar la instrucción: **pip3 install <nombre-paquete>.tar.gz**
- Cuando se desea usar el paquete se debe poner tanto el **from** como el **import**. La ventaja es que ya no necesitará una ruta absoluta o mantener el fichero en el mismo directorio, como se ha instalado con **pip** solo es necesario hacer la llamada pertinente.
- **Desinstalar paquete:** pip3 uninstall <nombre-paquete>.tar.gz
- NOTA: verificar instalación y desinstalación.

## Video 37 - Archivos externos I
- Módulo **io**.
- Objetivos:
    - Persistencia de datos.
- Alternativas:
    - Archivos externos.
    - Trabajar con BBDD.
- Fases:
    - Creación
    - Apertura
    - Manipulación
    - Cierre

## Video 38 - Archivos externos II
- Cuando se abre un archivo, la posición es al principio de todo, y al cerrarlo es la última donde se escribió. 
- Se puede conseguir con **read()** pero hay un matiz. **seek()** solo posiciona el puntero en el lugar que se especifica y **read()** hace una lectura hasta la posición del puntero que se le indica. Si se ejecuta dos veces el **read()**, uno con parámetro y otro sin, el primero lee hasta la posición X y el segundo lee a partir de donde se encuentra el puntero.
- Si se utiliza dos veces la functión **read()**, la segunda vez no mostraría nada porque el puntero estaría ubicado en la última posición.
- Método **seek()**: le decimos donde queremos que se sitúe el puntero.
- Se puede abrir un archivo como lectura y escritura utilizando: **r+**. El cursor se encontrará en la posición **0**.

## Video 39 - Serialización I
- Colecciones y objetos
- Consiste en guardar en un fichero externo una colección, diccionario u objeto. La particularidad es que se guarda en un fichero externo codificado en código binario.
- **¿Objetivo?** Si se quiere distribuir un objeto costruido en Python por internet, la distribución se hace más fácil. También para gurdarla en un dispositivo de almacenamiento externo, o guardar en una base de datos.
- Se requiere la biblioteca **Piclke**.

## Video 40 - Serialización II
- Si se crea y se abre desde otro archivo diferente, fallará. La única solución es copiar toda la definición del objeto en el segundo archivo, usto antes de realizar la lectura (abrirlo).

## Video 41 - Guardado permanente
- No hay notas

## Video 42 - Interfaces gráficas I
- "Intermediaro entre el programa que se ejecuta y nosotros."
- Librearía **Tkinter**, **WxPython**, **PyQT**, **PyGTK**.
    - Installar **Tkinter** => sudo apt-get install python3-tk
- Estructura de ventana con TKinter
    - **Raíz**: se conoce como "la ventana". Dentro va un **frame** como organizar/aglutinador de elementos.
    - **Frame**: dentro de este hay elementos conocidos como **widgets**. Un **Frame** también se considera como **widget**.
- Una ventana debe permanecer a la escucha de eventos.
- **mainloop()** debe ir **siempre** al final.
- Si se cambia la extensión del archivo a **.pyw** (en Windows), no aparece la consola por detrás.
- [Más info](https://docs.python.org/3.3/library/tk.html)

## Video 43 - Interfaces gráficas II - Frames
- Creación de frames: Raíz (TK) > Frame > Widgets

## Video 44 - Interfaces gráficas III - Labels
- Labels: permiten mostrar texto con el cual no se puede interactuar.
    - Pueden mostrar imagenes.

```python
variableLabel = Label(contenedor,opciones)
```
## Video 45 - Interfaces gráficas VI - Cuadro de texto
- Widget entry: cuadro de texto.
- Método grid: construye una tabla para colocar el contenido de forma ordenada.

# Video 46 - Interfaces gráficas V - Text y buttons
- Widets: text y button

# Video 47 - Interfaces gráficas VI - Calculadora
- Calculadora

# Video 48 - Interfaces gráficas VII - Calculadora
- Calculadora: insertando número
- Funciones anóminas (lambda): se simplifican la ejecución de funciones de manera anónima.

# Video 49 - Interfaces gráficas VIII - Calculadora
- Calculadora: añadida resta, multiplicación y división.

# Video 50 - Interfaces gráficas IX - Radiobuttons
- Radiobuttons
    - Se le debe asignar una variable para que se pueda seleccionar solo una opción.

# Video 51 - Interfaces gráficas X - Checkbuttons
- CheckButtons

# Video 52 - Interfaces gráficas XI - Menú
- Widget: menu

# Video 53 - Interfaces gráficas XII - Ventanas emergentes
- Ventanas emergentes
    - Hay que importarlas de forma independiente

```python
from tkinter import messagebox
```
# Video 54 - Interfaces gráficas XII - Ventanas emergentes: abrir archivos
- Filedialog: [Más info](https://pythonspot.com/tk-file-dialogs/)

# Video 55 - BBDD I
- SQL (Structured Query Language)
    - SQL Server
    - Oracle
    - MySQL
    - SQLite
        - ¿Que es?
            - Sistema de gestión de BBDD relacional.
            - Escrito en C, código abierto.
            - Forma parte integral del programa.
            - Se guarda como un único fichero en el host.
            - Tool: Sqlite browser.
        - Ventajas
            - Ocupa poco espacio en disco y memoria.
            - Eficiente y rápido.
            - Multiplataforma.
            - Sin adminsitración / configuración.
            - Dominio público, gratis.
        - Inconvenientes
            - No admite cláusulas anidadas (where).
            - No existen usuarios (no se puede acceder simultaneamente por varios usuarios a la vez).
            - Falta de clave foránea cuando se crea en modo consola.
    - PostgresSQL
- Pasos a seguir para conectar con la BBDD
    - Abrir-crear conexión.
    - Crear puntero.
    - Ejecutar query SQL.
    - Manejar resultados de la query.
        - Insertar, leer, actualizar, borrar. (Create, Read, Update, Delete).
    - Cerrar puntero.
    - Cerrar conexión.

# Video 56 - BBDD II
- Insertar y leer un lote de registros

# Video 57 - BBDD III
- Claves principales BBDD

# Video 58 - BBDD IV
- Cláusula UNIQUE.
- Operaciones CRUD.

# Video 59 - Práctica guiada I
- Explicación de la práctica.

# Video 60 - Práctica guiada II
- Grid.

# Video 61 - Práctica guiada III
- Aplicación gráfica CRUD.

# Video 62 - Práctica guiada IV
- Conexión a BBDD y salir de la aplicación.

# Video 63 - Práctica guiada V
- Limpiar campos e insertar registros

# Video 64 - Práctica guiada VI
- Leer y actualizar registros.

# Video 65 - Práctica guiada VII
- Borrar registros y consultas parametrizadas para la creación y la actualización.

# Video 66 - Funciones Lambda
- Función lambda = función anónima.
- Se utiliza para abreviar, ahorrar tiempo y que la sintáxis sea más ligera.
- Todo lo que se puede hacer con una función lambda se puede hacer con una función normal, pero no al revés.
- No se pueden utilizar con bucles o condicionales, solo podrá devolver un cálculo.
- Tambien se les denomina como funciones "on demand, on the go, online".

# Video 67 - Función Filter
- Grupo de funciones denominados funciones de orden superior.
- Permite usar paradigma de programación: programación funcional.
- POO o programación funcional.
- Filter: comprueba que los elementos de una secuencia (lista) cumple una condición, devolviendo un iterador con los elementos que cumplen dicha función.
- Se utiliza para filtrar objetos.

# Video 68 - Función Map
- Aplica una función a cada elemento de una lista iterable (listas, tuplas, etc) devolviendo una lista con los resultados.

# Video 69 - Expresiones regulares I
- **¿Qué son?**: "mini-lenguaje de programación dentro de otro lencuaje". Secuencia de caracteres que forman un patrón que sirven para realizar búsquedas (textos).
- Sintáxis
- Ejemplos sencillos
	1. Buscar un texto que se ajuste a un formato determinado (email, dominio, etc).
	2. Buscar si existe (o no) una cadena de caracteres dentro de un texto.
	3. Contar el número de coincidencias dentro de un texto.
	4. Etcétera.
- [Más info](https://docs.python.org/3/howto/regex.html)

# Video 70 - Expresiones regulares II
- Metacaracteres (caracteres comodí)
	- Anclas (permiten encontrar coincidencias de texto al comienzo o al final) y clases de caracteres.
		- **^**: Comienza por...
		- **$**: termina por...
		- **[]**: clases de caracteres. Los elementos que se pongan dentro de los corchetes serán patrones de búsqueda dentro de un texto.
			- **[sfg]**: buscará si el/los textos contienen los caracteres **sfg** pero **NO** en ese órden, simplemente si en un texto se encuentran esos caracteres.
			- **niñ[oa]s**: contiene **niñ** y puede proseguir por **o** u **a**, seguido de **s**.

# Video 71 - Expresiones regulares III
- **Rangos**: permiten buscar elementos dentro de una lista que contengan un rango de caracteres, números, que comiencen o terminen por un rango de caracteres o números, etc. Distingue entre mayúsculas y minúsculas.
	- **Elementos entre la o y la t:** [o-t]
	- **Rango negado (diferente)**: [^0-3]

# Video 72 - Expresiones regulares IV
- Funciones del módulo **re**:
	- **Match**: busca si hay coincidencias en un patrón de búsqueda al **comienzo**  de una cadena de texto.
	- **Search**: busca en toda la cadena de texto revisando si el patrón de búsqueda se cumple o no.
	- **Comodines**
		- **Punto .**: sustituye a un único caracter.
		- **\d**: si la cadena comienza (o no) por un número.

# Video 73 - Decoradores I
- **¿Qué son?**: funciones que a su vez añaden funcionalidades (decoran) a otras funciones que ya existan en el programa (les añaden funcionalidades).
- **Estructura**
	- Son 3 funciones (A, B y C), donde A recibe parámetro a B para devolver C. 
	- Devuelve una función.
- **Sintáxis**:
```python
# Función A + parámetro función B
def funcion_decorador(funcion): 
	def funcion_interna(): # Función C
		# código de la función interna
	return funcion_interna
```

# Video 74 - Decoradores II
- Decoradores con parámetros.
- **Nota:**
	- *args: Se le dice a una función de Python que recibirá un nº indeterminado de parámetros.
	- **kwargs (keyword arguments): parámetros con clave-valor

# Video 75 - Documentación
- Documentar programas.
- **¿Qué es?**: incluir comentarios en clases, módulos, métodos, etc.
- **¿Para qué?**: para ayudar en el trabajo en equipo. Especialmente útil en aplicaciones complejas.

# Video 76 - Documentación y pruebas
- Utilizar la documentación para realizar pruebas: **módulo doctest**

# Video 77 - Documentación y pruebas II

# Notas

- En Python todo es un objeto. Se puede ver el tipo con la función *type()*.
    ```python
    num=5
    type(num)
    <class 'int'>
    
    text="Hola"
    type(text)
    <class 'str'>
    #Puede tener multisalto utilizando triple comillas dobles (""")
    
    coma=5.2
    type(coma)
    <class 'float'>

- **__init__**
```python
class Empleado:
    def __init__(self, nombre, cargo, salario):
        self.nombre = nombre
        self.cargo = cargo
        self.salario = salario
```
    - El parámetro self se refiere al objeto instanciado de esa clase sobre el cual se está invocando dicho método.
    - Sin "self" la variable pasa a serlocal para ese método, pero con "self" se pueden ese método dentro de toda la clase.
    - [Más info](https://es.stackoverflow.com/questions/90357/para-qu%C3%A9-se-utiliza-self-en-poo-en-python)

- **__str__**
    - Sirve para poder imprimir llamando a una clase directamente, sin pasar por su método. Es un método que sirve para obtener la representación de tu objeto como string
    - [Más info](http://juanpabloaj.com/2016/08/06/Algunos-metodos-especiales-de-clase/)

    ```python
    class Animal:
        def __init__(self, nombre):
            self.nombre = nombre

    perro = Animal('bobby')
    print(perro.nombre)
    # bobby

    print(perro)
    # <__main__.Animal object at 0x1053fab38>

    class Animal:
        def __init__(self, nombre):
            self.nombre = nombre
        def __str__(self):
            return nombre

    perro = Animal('bobby')
    print(perro)
    # bobby
    ```

- **Argparser**
    - Se utiliza para hacer más amigables los scripts y poder mostrar información de argumentos a utilizar.

```python
# When you created the argument
arg4 = parser.add_argument("-c", "--check", help="performance metrics",action="store_true", dest="performance")

# The dest paramter told argparse to use a variable named performance, not check. Change your code to:
if args.performance:
    print("Check the performance of the server")
# or remove the dest param.
```

    - Más info
        - [Documentación oficial](https://docs.python.org/3/library/argparse.html)
		- [Explicación sencilla de como funciona](https://towardsdatascience.com/learn-enough-python-to-be-useful-argparse-e482e1764e05https://www.youtube.com/watch?v=4dkjpHI6vpA&list=PLU8oAlHdN5BlvPxziopYZRd55pdqFwkeS&index=68)
        - [Explicación de la opción "dest"](https://stackoverflow.com/questions/37126551/attributeerror-namespace-object-has-no-attribute-check)
		- Expresiones regulares
			- [Expresiones regulares con Python](https://relopezbriega.github.io/blog/2015/07/19/expresiones-regulares-con-python/)
			- [Módulo re en Python: expresiones regulares](https://blog.carreralinux.com.ar/2017/07/modulo-re-en-python-regex/)
			- [Guía de expresiones regulares en Python](https://platzi.com/blog/expresiones-regulares-python/)
			- [Expresiones Regulares con Python - Ejemplos Prácticos](http://www.pythondiario.com/2018/06/expresiones-regulares-con-python.html)